### ProxyFactoryBean 到底是什么？？？

如果不依赖 Spring 我们是这么实现动态代理的
```

public class CalculatorProxy {

    public static Object getInstance(final MyCalculatorImpl myCalculator) {
    
        return Proxy.newProxyInstance(CalculatorProxy.class.getClassLoader(), 
                                myCalculator.getClass().getInterfaces(), new InvocationHandler() {
            /**
             * @param proxy 代理对象
             * @param method 代理的方法
             * @param args 方法的参数
             */
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // 这里可以自己定义一些拦截链做一些业务逻辑处理
            
                System.out.println(method.getName()+"方法开始执行啦...");
                Object invoke = method.invoke(myCalculator, args);
                System.out.println(method.getName()+"方法执行结束啦...");
                return invoke;
            }
        });
    }
}

```
如果业务逻辑复杂，使用起来就没那么方便了，那么 ProxyFactoryBean 就是基于 
Spring 封装了 jdk 动态代理和 cglib 代理，让我们使用起来方便快捷，只需要在 xml 中
配置拦截器就可以了。

```dtd
    <!-- 第一类 -->
    <bean id="countInterceptor" class="org.springframework.aop.bing.interceptor.CountInterceptor"/>
    <bean id="timeCountInterceptor"
          class="org.springframework.aop.bing.interceptor.TimeCountInterceptor"/>
    <!-- 第二类 -->
    <bean id="myAdvisor"
          class="org.springframework.aop.bing.interceptor.MyAdvisor"/>
    <!-- 第三类 -->
    <bean id="myMethodBeforeAdvice"
          class="org.springframework.aop.bing.interceptor.MyMethodBeforeAdvice"/>

    <bean id="dog" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="interfaces" value="org.springframework.aop.bing.service.DogService"/>
        <property name="target" ref="targetDog"/>

        <property name="interceptorNames" value="countInterceptor,timeCountInterceptor,myAdvisor,myMethodBeforeAdvice"/>
        <!--<property name="proxyTargetClass" value="true"/>-->
    </bean>
```

interceptorNames 最终被 initializeAdvisorChain 方法 转化成 Advisor 链 ，可以定义三类对象：DefaultAdvisorAdapterRegistry.wrap 可详细查看

- 第一类：MethodInterceptor 对象，其实也是 Advice 子类，最后被包装成 DefaultPointcutAdvisor
- 第二类：Advisor 对象，不用包装，本身就是 Advisor
- 第三类：Advice 对象(需要有适配器 AdvisorAdapter 支持)，跟上面 Advisor 对象其实差不多，最后被包装成 DefaultPointcutAdvisor

> AdvisorAdapter 默认三种适配器 ，适配：MethodBeforeAdvice、ThrowsAdvice、AfterReturningAdvice，每一种对应一种内置的拦截器
所以第三类 Advice 对象 只能继承上面三种

代理方法最终被调用的时候 需要将 advisor  链转化成 MethodInterceptor 链，如果 advisor 内部是 advice ，则通过适配器来转化成拦截器

简单来说，就是 aop 帮我们定义了几种内置拦截器，我们只需要关心我们想在真实方法的【什么位置干什么事情】就可以了，这估计就是设计模式的厉害之处，
把公共的地方抽取出来，留下不同之处给我们配置

设想一下，如果要我们自己设计一种方式，达到 aop 的效果，会怎么做？


ProxyFactoryBean 缺点 ：一个 ProxyFactoryBean 只能针对某个对象做代理，如果要代理的对象很多，那么配置起来就麻烦了，需要一一配置。

一个拦截器通常可以在下面几个地方做拦截操作，但是想要批量对多个类做一样的拦截操作，比如想在所有的 service 方法
【调用结束时】打印耗时，还想在某些方法【调用开始时】打印开始时间，那么用 ProxyFactoryBean 就有非常大的局限性了，配置非常麻烦

```
public class CountInterceptor implements MethodInterceptor {

  @Override
  public Object invoke(MethodInvocation invocation) throws Throwable {
    begin();
    try {
      Object proceed = invocation.proceed();
      commit();
    } catch (Throwable throwable) {
      rollback(throwable);
    } finally {
      finallyInvoke();
    }
  }
}

```
那么有没有灵活多变的配置方式呢，有，下面就是
```dtd
    <aop:config>
        <!-- 切点: 哪些类的哪些方法需要被代理 -->
        <aop:pointcut id="servicePointcut"
                      expression="execution(* org.springframework.aop.bing.service.CatService.*(..))"/>
        <!-- 切面 -->
        <aop:aspect ref="txAspect">
            <!-- 之前 -->
            <!-- 每一个 通知 都会解析生成一个 AspectJPointcutAdvisor 对象, 最后转化为一个拦截器，拦截器再调用 txAspect 对应的方法 -->
            <aop:before method="begin" pointcut-ref="servicePointcut"/>

            <!-- 正常结束之后 -->
            <!-- 这个通知表示 servicePointcut 代表的那些方法，真正执行结束之后 会去执行 拦截器 txAspect 的 commit 方法 -->
            <aop:after-returning method="commit" pointcut-ref="servicePointcut"/>
 
            <!-- 环绕通知  替代上面所有 -->
            <!-- 这个通知表示 servicePointcut 代表的那些方法，真正执行的时机 会在拦截器 txAspect 的
                 around 方法中，至于方法执行前，执行后或异常后等地方会做什么拦截操作，取决于 around 方法怎么定义的 -->
            <aop:around method="around" pointcut-ref="servicePointcut"/>
        </aop:aspect>
    </aop:config>
```

经过上述配置后，Spring 容器初始化的时候会将 xml 解析成很多 AspectJPointcutAdvisor 对象，放入容器中，
在后置处理 bean 的时候，再全部找出来，匹配到合适的 advisor 构成 advisor 链，再生成代理对象，在方法真实调用的时候，advisor 链最后转化成 拦截器链













